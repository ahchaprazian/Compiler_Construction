
%{
/*
YYSTYPE is the lexical value returned by each rule in a bison grammar.
By default, it is an integer. In this example, we are returning a pointer to an expr.

*/

/*
Clunky: Manually declare the interface to the scanner generated by flex.
*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "expr.h"
#include "stmt.h"
#include "decl.h"
#include "param_list.h"
#include "type.h"

extern char *yytext;
extern int yylex();
extern int yyerror( char *str );
extern int yylineno;
extern int yydebug;
struct decl * parser_result = 0;

%}

%token TOKEN_EOF
%token TOKEN_IDENT
%token TOKEN_ERROR

/* DATA TYPES AND KEYWORDS */
%token TOKEN_CHAR
%token TOKEN_INTEGER
%token TOKEN_STRING
%token TOKEN_ARRAY
%token TOKEN_AUTO
%token TOKEN_VOID
%token TOKEN_BOOLEAN
%token TOKEN_FALSE
%token TOKEN_TRUE
%token TOKEN_IF
%token TOKEN_FOR
%token TOKEN_PRINT
%token TOKEN_RETURN
%token TOKEN_FUNCTION
%token TOKEN_ELSE
%token TOKEN_WHILE
%token TOKEN_COLON
%token TOKEN_SEMICOLON
%token TOKEN_COMMA

/* EXPRESSIONS */
%token TOKEN_LPAREN
%token TOKEN_RPAREN
%token TOKEN_LCURLY
%token TOKEN_RCURLY
%token TOKEN_LBRACKET
%token TOKEN_RBRACKET
%token TOKEN_INCREMENT
%token TOKEN_DECREMENT
%token TOKEN_NOT
%token TOKEN_EXPONENT
%token TOKEN_MULT
%token TOKEN_DIV
%token TOKEN_MOD
%token TOKEN_PLUS
%token TOKEN_MINUS
%token TOKEN_LT
%token TOKEN_LTE
%token TOKEN_GT
%token TOKEN_GTE
%token TOKEN_EQUAL
%token TOKEN_NOTEQ
%token TOKEN_AND
%token TOKEN_OR
%token TOKEN_ASSIGN
%token TOKEN_FUNCCALL

%token TOKEN_LIT_STR
%token TOKEN_LIT_CHAR
%token TOKEN_LIT_INT

%union {
    struct decl *decl;
    struct stmt *stmt;
    struct expr *expr;
    struct type *type;
    struct param_list *param_list;
    char *ident;
    int number;
    char letter;
    char *word;
}

%type <decl> program translation_unit functions external_declaration declaration
%type <stmt> statements open_statement closed_statement other_statements
%type <expr> expression logical_and_expr logical_or_expr relational_expr addsub_expr mult_expr exp_expr unary_expr postfix_expr grouping expr_list square_brackets loop_params_maybe types
%type <type> array arrnosize arrsize type_specifier //type_or_specifier_keywords
%type <param_list> parameter_list
%type <ident> ident
%type <number> lit_int bool_false bool_true
%type <word> lit_str
%type <letter> lit_char

%%
program
    : translation_unit  { parser_result = $1; }
    ;

translation_unit
    : external_declaration translation_unit { $$ = $1, $1->next = $2; }
    | %empty    { parser_result = NULL; }
    ;

// Variables and functions
external_declaration
    : functions     { $$ = $1; }
    | declaration   { $$ = $1; }
    ;

/****** FUNCTION DEFINITIONS AND DECLARATIONS ******/
// Takes cares of prototypes and definition.
functions
    // Function declarations
    : ident TOKEN_COLON TOKEN_FUNCTION type_specifier TOKEN_LPAREN parameter_list TOKEN_RPAREN TOKEN_ASSIGN TOKEN_LCURLY statements TOKEN_RCURLY    { $$ = decl_create($1, type_create(TYPE_FUNCTION, $4, $6, 0), 0, $10, 0); }
    | ident TOKEN_COLON TOKEN_FUNCTION type_specifier TOKEN_LPAREN TOKEN_RPAREN TOKEN_ASSIGN TOKEN_LCURLY statements TOKEN_RCURLY    { $$ = decl_create($1, type_create(TYPE_FUNCTION, $4, 0, 0), 0, $9, 0); }
    // Function prototypes
    | ident TOKEN_COLON TOKEN_FUNCTION type_specifier TOKEN_LPAREN parameter_list TOKEN_RPAREN TOKEN_SEMICOLON { $$ = decl_create($1, type_create(TYPE_FUNCTION_PROTO, $4, $6, 0), 0, 0, 0); }
    | ident TOKEN_COLON TOKEN_FUNCTION type_specifier TOKEN_LPAREN TOKEN_RPAREN TOKEN_SEMICOLON { $$ = decl_create($1, type_create(TYPE_FUNCTION_PROTO, $4, 0, 0), 0, 0, 0); }
    ;

declaration
    : ident TOKEN_COLON type_specifier TOKEN_SEMICOLON { $$ = decl_create($1, $3, 0, 0, 0); }
    | ident TOKEN_COLON array TOKEN_SEMICOLON { $$ = decl_create($1, $3, 0, 0, 0); }
    | ident TOKEN_COLON type_specifier TOKEN_ASSIGN expression TOKEN_SEMICOLON      { $$ = decl_create($1, $3, $5, 0, 0); }
    | ident TOKEN_COLON array TOKEN_ASSIGN TOKEN_LCURLY expr_list TOKEN_RCURLY TOKEN_SEMICOLON  { $$ = decl_create($1, $3, $6, 0, 0); }
    ;

parameter_list
    : ident TOKEN_COLON type_specifier TOKEN_COMMA parameter_list { $$ = param_list_create($1, $3, $5); }
    | ident TOKEN_COLON type_specifier    { $$ = param_list_create($1, $3, 0); }
    | ident TOKEN_COLON arrnosize TOKEN_COMMA parameter_list { $$ = param_list_create($1, $3, $5); }
    | ident TOKEN_COLON arrnosize     { $$ = param_list_create($1, $3, 0); }
    ;

/****** EXPRESSIONS ******/
expression
    : expression TOKEN_ASSIGN logical_or_expr   { $$ = expr_create(EXPR_ASSIGN, $1, $3); }
    | logical_or_expr   { $$ = $1; }
    ;

logical_or_expr
    : logical_or_expr TOKEN_OR logical_and_expr { $$ = expr_create(EXPR_OR, $1, $3); }
    | logical_and_expr  { $$ = $1; }
    ;

logical_and_expr
    : logical_and_expr TOKEN_AND relational_expr    { $$ = expr_create(EXPR_AND, $1, $3); }
    | relational_expr { $$ = $1; }
    ;

relational_expr
    : relational_expr TOKEN_LT addsub_expr          { $$ = expr_create(EXPR_LT, $1, $3); }
    | relational_expr TOKEN_GT addsub_expr          { $$ = expr_create(EXPR_GT, $1, $3); }
    | relational_expr TOKEN_LTE addsub_expr         { $$ = expr_create(EXPR_LEQ, $1, $3); }
    | relational_expr TOKEN_GTE addsub_expr         { $$ = expr_create(EXPR_GEQ, $1, $3); }
    | relational_expr TOKEN_EQUAL addsub_expr       { $$ = expr_create(EXPR_EQUAL, $1, $3); }
    | relational_expr TOKEN_NOTEQ addsub_expr       { $$ = expr_create(EXPR_NOTEQ, $1, $3); }
    | addsub_expr                                   { $$ = $1; }
    ;

addsub_expr
    : addsub_expr TOKEN_PLUS mult_expr              { $$ = expr_create(EXPR_ADD, $1, $3); }
    | addsub_expr TOKEN_MINUS mult_expr             { $$ = expr_create(EXPR_MINUS, $1, $3); }
    | mult_expr                                     { $$ = $1; }
    ;

mult_expr
    : mult_expr TOKEN_MULT exp_expr                 { $$ = expr_create(EXPR_MULT, $1, $3); }
    | mult_expr TOKEN_DIV exp_expr                  { $$ = expr_create(EXPR_DIV, $1, $3); }
    | mult_expr TOKEN_MOD exp_expr                  { $$ = expr_create(EXPR_MOD, $1, $3); }
    | exp_expr                                      { $$ = $1; }
    ;

exp_expr
    : exp_expr TOKEN_EXPONENT unary_expr            { $$ = expr_create(EXPR_EXPONENT, $1, $3); }
    | unary_expr                                    { $$ = $1; }
    ;

unary_expr
    : TOKEN_MINUS postfix_expr                      { $$ = expr_create(EXPR_NEGATION, $2, 0); }
    | TOKEN_NOT postfix_expr                        { $$ = expr_create(EXPR_NOT, $2, 0); }
    | postfix_expr                                  { $$ = $1; }
    ;

postfix_expr
    : postfix_expr TOKEN_INCREMENT                  { $$ = expr_create(EXPR_INCREMENT, $1, 0); }
    | postfix_expr TOKEN_DECREMENT                  { $$ = expr_create(EXPR_DECREMENT, $1, 0); }
    | grouping                                      { $$ = $1; }
    ;

// () []  function_call()
grouping
    : ident TOKEN_LPAREN expr_list TOKEN_RPAREN { $$ = expr_create(EXPR_FUNC_CALL, expr_create_name($1), $3); } // Function call stuff
    | ident TOKEN_LPAREN TOKEN_RPAREN           { $$ = expr_create(EXPR_FUNC_CALL, expr_create_name($1), 0); } // Function call stuff
    | TOKEN_LPAREN expr_list TOKEN_RPAREN       { $$ = expr_create(EXPR_GROUPING, $2, 0); }
    | TOKEN_LPAREN TOKEN_RPAREN                 { $$ = expr_create(EXPR_GROUPING, 0, 0); }
    | TOKEN_LCURLY expr_list TOKEN_RCURLY       { $$ = expr_create(EXPR_CURLY, $2, 0); }
    | ident square_brackets                     { $$ = expr_create(EXPR_ARRAY_INDEX, expr_create_name($1), $2); } // Array[...]
    | types                                     { $$ = $1; }
    ;

types
    : lit_int       { $$ = expr_create_integer_literal($1); }
    | lit_char      { $$ = expr_create_char_literal(yytext[1]); }
    | lit_str       { $$ = expr_create_string_literal($1); }
    | ident         { $$ = expr_create_name($1); }
    | bool_true     { $$ = expr_create_boolean_literal($1); }
    | bool_false    { $$ = expr_create_boolean_literal($1); }
    | array         { $$ = expr_create_array_type($1); }
    ;

lit_int
    : TOKEN_LIT_INT     { $$ = atoi(yytext); }
    ;

lit_str
    : TOKEN_LIT_STR     { $$ = strdup(yytext); }
    ;

lit_char
    : TOKEN_LIT_CHAR    { $$ = strdup(yytext)[0]; }
    ;

ident
    : TOKEN_IDENT       { $$ = strdup(yytext); }
    ;

bool_true
    : TOKEN_TRUE        { $$ = 1; }
    ;

bool_false
    : TOKEN_FALSE       { $$ = 0; }
    ;

// AUTO is in teh currect spot. Skipped a step.
// Gets type keyword or auto
//type_or_specifier_keywords
//    : TOKEN_AUTO                                { $$ = type_create(TYPE_AUTO, 0, 0, 0); }
//    | TOKEN_AUTO type_or_specifier_keywords     { $$ = type_create(TYPE_AUTO, 0, 0, 0); }
//    | type_specifier                            { $$ = $1; }
//    | type_specifier type_or_specifier_keywords { $$ = $2; }    // might not do anything
//   ;

type_specifier
    : TOKEN_VOID    { $$ = type_create(TYPE_VOID, 0, 0, 0); }
    | TOKEN_INTEGER { $$ = type_create(TYPE_INTEGER, 0, 0, 0); }
    | TOKEN_STRING  { $$ = type_create(TYPE_STRING, 0, 0, 0); }
    | TOKEN_CHAR    { $$ = type_create(TYPE_CHARACTER, 0, 0, 0); }
    | TOKEN_BOOLEAN { $$ = type_create(TYPE_BOOLEAN, 0, 0, 0); }
    ;

array
    : arrsize       { $$ = $1; }
    | arrnosize     { $$ = $1; }
    ;

// For declarations and init
arrsize
    : TOKEN_ARRAY TOKEN_LBRACKET lit_int TOKEN_RBRACKET type_specifier  { $$ = type_create(TYPE_ARRAY, $5, 0, $3); }
    | TOKEN_ARRAY TOKEN_LBRACKET lit_int TOKEN_RBRACKET arrsize         { $$ = type_create(TYPE_ARRAY, $5, 0, $3); }
    ;

arrnosize
    : TOKEN_ARRAY TOKEN_LBRACKET TOKEN_RBRACKET type_specifier  { $$ = type_create(TYPE_ARRAY, $4, 0, 0); }
    | TOKEN_ARRAY TOKEN_LBRACKET TOKEN_RBRACKET arrnosize       { $$ = type_create(TYPE_ARRAY, $4, 0, 0); }
    ;

// Takes care of arrays and [][](and so on) arrays
square_brackets
    : TOKEN_LBRACKET expression TOKEN_RBRACKET square_brackets  { $$ = expr_create(EXPR_BRACKETS, $2, $4); }
    | TOKEN_LBRACKET expression TOKEN_RBRACKET                  { $$ = $2; }
    | TOKEN_LBRACKET statements TOKEN_RBRACKET square_brackets  { $$ = expr_create(EXPR_BRACKETS, $2, $4); }
    | TOKEN_LBRACKET statements TOKEN_RBRACKET                  { $$ = $2; }
    ;

/****** LOOPS AND STATEMENTS ******/
// Includes if, for, while, print and return
statements
    : open_statement statements     { $$ = $1, $1->next = $2; }
    | closed_statement statements   { $$ = $1, $1->next = $2; }
    | open_statement                { $$ = $1; }
    | closed_statement              { $$ = $1; }
    ;

// Represents an open body of code.
open_statement
    : TOKEN_IF TOKEN_LPAREN expression TOKEN_RPAREN open_statement
        { $$ = stmt_create(STMT_IF, 0, 0, $3, 0, $5, 0, 0); }
    | TOKEN_IF TOKEN_LPAREN expression TOKEN_RPAREN closed_statement
        { $$ = stmt_create(STMT_IF, 0, 0, $3, 0, $5, 0, 0); }
    | TOKEN_IF TOKEN_LPAREN expression TOKEN_RPAREN closed_statement TOKEN_ELSE open_statement
        { $$ = stmt_create(STMT_IF_ELSE, 0, 0, $3, 0, $5, $7, 0); }
    | TOKEN_FOR TOKEN_LPAREN loop_params_maybe TOKEN_SEMICOLON loop_params_maybe TOKEN_SEMICOLON loop_params_maybe TOKEN_RPAREN open_statement
        { $$ = stmt_create(STMT_FOR, 0, $3, $5, $7, $9, 0, 0); }
    //| TOKEN_WHILE TOKEN_LPAREN loop_params_maybe TOKEN_RPAREN closed_statement
    //    { $$ = stmt_create(STMT_WHILE, 0, 0, $3, 0, $5, 0, 0); }
    ;

// Represents closed bodies of code.
closed_statement
    : TOKEN_IF TOKEN_LPAREN expression TOKEN_RPAREN closed_statement TOKEN_ELSE closed_statement
        { $$ = stmt_create(STMT_IF_ELSE, 0, 0, $3, 0, $5, $7, 0); }
    | TOKEN_FOR TOKEN_LPAREN loop_params_maybe TOKEN_SEMICOLON loop_params_maybe TOKEN_SEMICOLON loop_params_maybe TOKEN_RPAREN closed_statement
        { $$ = stmt_create(STMT_FOR, 0, $3, $5, $7, $9, 0, 0); }
    //| TOKEN_WHILE TOKEN_LPAREN loop_params_maybe TOKEN_RPAREN closed_statement
    //    { $$ = stmt_create(STMT_WHILE, 0, 0, $3, 0, $5, 0, 0); }
    | other_statements
        { $$ = $1; }
    ;

// (;;) or (x:int=...;x<y;x++)
loop_params_maybe
    : %empty        { $$ = 0; }
    | expression    { $$ = $1; }
    ;

// excluds if/loop statements
other_statements
    : TOKEN_PRINT expr_list TOKEN_SEMICOLON     { $$ = stmt_create(STMT_PRINT, 0, 0, $2, 0, 0, 0, 0); }
    | TOKEN_PRINT TOKEN_SEMICOLON               { $$ = stmt_create(STMT_PRINT, 0, 0, 0, 0, 0, 0, 0); }
    | TOKEN_RETURN expression TOKEN_SEMICOLON   { $$ = stmt_create(STMT_RETURN, 0, 0, $2, 0, 0, 0, 0); }
    | TOKEN_RETURN TOKEN_SEMICOLON              { $$ = stmt_create(STMT_RETURN, 0, 0, 0, 0, 0, 0, 0); }
    | TOKEN_LCURLY statements TOKEN_RCURLY      { $$ = stmt_create(STMT_BLOCK, 0, 0, 0, 0, $2, 0, 0); }
    | expression TOKEN_SEMICOLON                { $$ = stmt_create(STMT_EXPR, 0, 0, $1, 0, 0, 0, 0); }
    | declaration                               { $$ = stmt_create(STMT_DECL, $1, 0, 0, 0, 0, 0, 0); }
    ;

/****** MISC ******/
expr_list
    : expr_list TOKEN_COMMA expression  { $$ = expr_create(EXPR_ARGS, $1, $3); }
    | expression                        { $$ = $1; }
    ;

%%

int yyerror(char* str) {
    printf("ERROR: parse failed on line %d\n", yylineno);
    return 1;
}